// Copyright (C) 2008 Naoyuki Hirayama.
// All Rights Reserved.

// $Id$

#include "caper_ast.hpp"
#include "caper_generate_cpp.hpp"
#include "caper_format.hpp"
#include "caper_stencil.hpp"
#include "caper_finder.hpp"
#include <algorithm>
#include <boost/tuple/tuple.hpp>
#include <boost/tuple/tuple_comparison.hpp>

namespace {

void make_action_case(
    std::ostream&                           os,
    int                                     indent, 
    const tgt::parsing_table::action_entry& action_entry) {
    // action
    switch (action_entry.type) {
        case zw::gr::action_shift:
            stencil_indent(
                os, indent, R"(
                // shift
                shifters.push([this.clone(), ${dest_index}, tnode]);
)",
                {"dest_index", action_entry.dest_index}
                );
            break;
        case zw::gr::action_reduce: {
            stencil_indent(
                os, indent, R"(
                // reduce
                this.popStack(
                    ${base}, Nonterminal.${nonterminal}, reducers, null, age);
)",
                {"base", action_entry.rule.right().size()},
                {"nonterminal", action_entry.rule.left().name()}
                );
        }
            break;
        case zw::gr::action_accept:
            stencil_indent(
                os, indent, R"(
                // accept
                accepts.push(this.stack);
)"
                );
            break;
        case zw::gr::action_error:
            stencil_indent(
                os, indent, R"(
                this.sa.syntaxError();
                this.error = true;
                break;
)"
                );
            break;
    }
}

}

void generate_glr_javascript(
    const std::string&                  src_filename,
    std::ostream&                       os,
    const GenerateOptions&              options,
    const std::map<std::string, Type>&,
    const std::map<std::string, Type>&  nonterminal_types,
    const std::vector<std::string>&     tokens,
    const action_map_type&              actions,
    const tgt::parsing_table&           table) {

    // notice / URL
    stencil(
        os, R"(
// This file was automatically generated by Caper.
// (http://jonigata.github.io/caper/caper.html)

var ${namespace_name} = (function() {

    var exports = {};

)",
        {"namespace_name", options.namespace_name}
        
        );

    if (!options.external_token) {
        // token enumeration
        stencil(
            os, R"(
    var Token = {
$${tokens}
        null : null
    };
    exports.Token = Token;

    var getTokenLabel = function(t) {
        var labels = [
$${labels}
            null
        ];
        return labels[t];
    };
    exports.getTokenLabel = getTokenLabel;

)",
            {"tokens", [&](std::ostream& os){
                    int index = 0;
                    for(const auto& token: tokens) {
                        stencil(
                            os, R"(
        ${prefix}${token}: ${index},
)",
                            {"prefix", options.token_prefix},
                            {"token", token},
                            {"index", index}
                            );
                        index++;
                    }
                }},
            {"labels", [&](std::ostream& os){
                    for(const auto& token: tokens) {
                        stencil(
                            os, R"(
            "${token}",
)",
                            {"token", token}
                            );
                    }
                }}
            );

    }

    // nonterminal
    stencil(
        os, R"(
    var Nonterminal = {
)"
        );
    {
        int index = 0;
        for (const auto& nonterminal_type: nonterminal_types) {
            stencil(
                os, R"(
        ${nonterminal_name}: ${index},
)",
                {"nonterminal_name", nonterminal_type.first},
                {"index", index}
                );
            index++;
        }
    }
    stencil(
        os, R"(
        null: null
    };
    var getNonterminalLabel = function(t) {
        var labels = [
$${labels}
            null
        ];
        return labels[t];
    };
)",
        {"labels", [&](std::ostream& os){
                for (const auto& nonterminal_type: nonterminal_types) {
                    stencil(
                        os, R"(
            "${nonterminal_name}",
)",
                        {"nonterminal_name", nonterminal_type.first}
                        );
                }
            }}
        );
    
    stencil(
        os, R"(

    // data Node = TNode | NNode

    var nodeIndex = 0;
    var tNodeIndex = 0;
    function TNode(token, value) {
        this.nodeType = 'TNode';
        this.nodeIndex = nodeIndex++;
        this.token = token;
        this.value = value;
        this.x = tNodeIndex++;
        this.depth = 0;

        this.toString = function() {
            return getTokenLabel(this.token)+': "'+this.value+'"';
        };
        this.collect = function(nodes, depth) {
            nodes[this.nodeIndex] = this;
            if (this.depth < depth) {
                this.depth = depth;
            }
        };
    }

    function NNode(nonterminal, successors) {
        this.nodeType = 'NNode';
        this.nodeIndex = nodeIndex++;
        this.nonterminal = nonterminal;
        this.successors = [successors];
        this.depth = 0;

        this.toString = function() {
            return getNonterminalLabel(this.nonterminal);
        };
        this.collect = function(nodes, depth) {
            nodes[this.nodeIndex] = this;
            if (this.depth < depth) {
                this.depth = depth;
            }
            var x = 0;
            var n = 0;
            for(var i = 0 ; i < this.successors.length ; i++) {
                var successors = this.successors[i];
                for(var j = 0 ; j < successors.length ; j++) {
                    var node = successors[j];
                    if (node != null) {
                        node.collect(nodes, depth+1);
                    }
                    x += node.x;
                    n++;
                }
            }
            this.x = x / n;
        };
    }

    var vertexIndex = 0;
    function Vertex(entry, n, prev, age) {
        this.entry = entry;
        this.node = n;
        this.prev = [prev];
        if (prev == null) {
            this.x = 0;
            this.y = 0;
        } else {
            this.x = age;
            this.y = prev.rightY;
            prev.rightY += 1;
        }
        this.rightY = this.y;
        this.index = vertexIndex++;
    }

    function Cons(car, cdr) {
        this.car = car;
        this.cdr = cdr;
    }

)");

    // slice constructor
    stencil(
        os, R"(
    function Slice(sa, stack) {
        this.sa = sa;

        this.stack = stack;
        this.error = false;

)",
        {"first_state", table.first_state()}
        );

    // table
    stencil(
        os, R"(
        var entries = [
$${entries}
            null
        ];

        this.entry = function(n) {
            return entries[n];
        };

)",
        {"entries", [&](std::ostream& os) {
                for (int i = 0 ; i < table.states().size() ; i++) {
                    stencil(
                        os, R"(
            { state: this.state_${i}, gotof: this.gotof_${i}, index: ${i} },
)",
                            
                        {"i", i}
                        );
                }                    
            }}
        );

    
    stencil(
        os, R"(
        if (this.stack == null) {
            this.pushStack(${first_state}, null, 0);
        }
    }
    exports.Slice = Slice;

    Slice.prototype = {
        dumpAux : function(s) {
            if (s == null) {
                return "";
            } else {
                return this.dumpAux(s.prev[0]) + ", " + (s.node == null ? "null" : s.node.toString());
            }
        },
        dump : function() {
            console.log(this.stack.entry.index + ": " + this.dumpAux(this.stack));
        },
        clone : function() {
            return new Slice(this.sa, this.stack);
        },
        combinable : function(slice) {
            var xs = this.stack;
            var ys = slice.stack;
            if (xs.entry.index != ys.entry.index) {
                return false;
            }
            if (xs.node.nodeType == 'TNode') {
                if (ys.node.nodeType != 'TNode' ||
                    xs.node.token != ys.node.token) {
                    throw "internal error";
                }
                return xs.node.value == ys.node.value;
            } else {
                if (ys.node.nodeType != 'NNode' ||
                    xs.node.nonterminal != ys.node.nonterminal) {
                    throw "internal error";
                }
                return true;
            }
        },
        combine : function(slice) {
            this.stack.prev = this.stack.prev.concat(slice.stack.prev);
            if (this.stack.node.nodeType == 'NNode') {
                this.stack.node.successors = 
                    this.stack.node.successors.concat(
                        slice.stack.node.successors);
            }
        },
        postToReduce : function(token, tnode, shifters, reducers, accepts, age) {
            this.error = false;
            this.stack.entry.state.apply(
                this, [token, tnode, shifters, reducers, accepts, age]);
        },
        postToShift : function(state, node, age) {
            this.pushStack(state, node, age);
        },
        getError : function() {
            return this.error;
        },

)",
        {"first_state", table.first_state()}
        );

    // stack operation
    stencil(
        os, R"(
        pushStack : function(stateIndex, v, age) {
            this.stack = new Vertex(this.entry(stateIndex), v, this.stack, age);
        },
        popStack : function(n, nonterminal, reducers, args, age) {
            if (n == 0) {
                var a = [];
                while(args != null) {
                    a.push(args.car);
                    args = args.cdr;
                }
                this.pushStack(
                    this.stack.entry.gotof.apply(this, [nonterminal]),
                    new NNode(nonterminal, a),
                    age-1);
                reducers.push(new Slice(this.sa, this.stack));
                return;
            }
            args = new Cons(this.stack.node, args);
            for(var i = 0 ; i < this.stack.prev.length ; i++) {
                new Slice(
                    this.sa, this.stack.prev[i]).popStack(
                        n-1, nonterminal, reducers, args, age);
            }
        },

)"
        );

    // states handler
    for (const auto& state: table.states()) {
        // state header
        stencil(
            os, R"(
        state_${state_no} : function(token, tnode, shifters, reducers, accepts, age) {
$${debmes:state}
            switch(token) {
)",
            {"state_no", state.no},
            {"debmes:state", [&](std::ostream& os){
                    if (options.debug_parser) {
                        stencil(
                            os, R"(
            console.log("state_${state_no} << " + getTokenLabel(token));
)",
                            {"state_no", state.no}
                            );
                    }}}
            );

        // action table
        for (const auto& pair: state.action_table) {
            const auto& token = pair.first;
            const auto& action = pair.second;

            std::string case_tag =
                "Token." + options.token_prefix + tokens[token];

            // action header 
            stencil(
                os, R"(
            case ${case_tag}:
)",
                {"case_tag", case_tag},
                {"candidates", action.entries.size()}
                );

            // for each fork
            for(const auto& action_entry: action.entries) {
                make_action_case(
                    os,
                    0,
                    action_entry);
            }
            stencil(
                os, R"(
                break;
)"
                );
        }

        // dispatcher footer / state footer
        stencil(
            os, R"(
            default:
                this.sa.syntaxError();
                this.error = true;
                return false;
            }
        },

)"
            );
        
        // gotof header
        stencil(
            os, R"(
        gotof_${state_no} : function(nonterminal) {
)",
            {"state_no", state.no}
            );
            
        // gotof dispatcher
        std::stringstream ss;
        stencil(
            ss, R"(
            switch(nonterminal) {
)"
            );
        bool output_switch = false;
        for (const auto& pair: state.goto_table) {
            stencil(
                ss, R"(
            case Nonterminal.${nonterminal}: return ${state_index};
)",
                {"nonterminal", pair.first.name()},
                {"state_index", pair.second}
                );
            output_switch = true;
        }

        // gotof footer
        stencil(
            ss, R"(
            default:
                console.log(getNonterminalLabel(nonterminal));
                throw "unexpected nontermninal";
            }
)"
            );
        if (output_switch) {
            os << ss.str();
        } else {
            stencil(
                os, R"(
            throw "unexpected gotof";
)"
                );
        }
        stencil(os, R"(
        },

)"
            );
    }
    stencil(os, R"(
        dummy : null
    };

    function Parser(sa) {
        this.slices = [];
        this.slices.push(new Slice(sa, null));
        this.accepts = [];
        this.age = 1;
    }
    exports.Parser = Parser;

    Parser.prototype = {
        post: function(token, value) {
            var combine = function(src, sin, din, dout) {
                var dst = [];
                for (var i = 0 ; i < src.length ; i++) {
                    var newer = sin(src[i]);
                    var kill = false;
                    for(var j = 0  ; j < dst.length ; j++) {
                        var fixed = din(dst[j]);
                        if (fixed.combinable(newer)) {
                            // unite
                            kill = true;
                            fixed.combine(newer);
                            console.log("killed");
                            break;
                        }
                    }
                    if (!kill) {
                        dst.push(dout(src[i]));
                    }
                }
                return dst;
            };

            console.log("post " + token + ", " + value);
            var tnode = new TNode(token, value);

            var actives = [];
            for(var i = 0 ; i < this.slices.length ; i++) {
                actives.push(this.slices[i]);
            }

            var shifters = [];
            while (0 < actives.length) {
                var reducers = [];
                var curr = actives.shift();
                curr.postToReduce(token, tnode, shifters, reducers, this.accepts, this.age);
                
                actives = combine(
                    reducers.concat(actives),
                    function(x) { return x; },
                    function(x) { return x; },
                    function(x) { return x; });
            }

            if (this.slices.length < shifters.length) {
                console.log("forked " + (shifters.length - this.slices.length));
            }

            shifters = combine(
                shifters,
                function(x) { return x[0]; },
                function(x) { return x[0]; },
                function(x) { return x; });
            for (var i = 0 ; i < shifters.length ; i++) {
                var tuple = shifters[i];
                tuple[0].postToShift(tuple[1], tuple[2], this.age);
            }

            this.slices = combine(
                shifters,
                function(x) { return x[0]; },
                function(x) { return x; },
                function(x) { return x[0]; });

            for (var k = 0 ; k < this.slices.length ; k++) {
                //this.slices[k].dump();
            }
            this.age++;
            console.log(this.accepts.join(', '));

            return 0 < this.accepts.length;
        },
        draw: function(drawer) {
            // collect all living vertices
            var totalSet = {};
            var currSet = {};
            for (var i = 0 ; i < this.accepts.length ; i++) {
                var p = this.accepts[i];
                currSet[p.index] = p;
            }

            for (var i = 0 ; i < this.slices.length ; i++) {
                var p = this.slices[i].stack;
                currSet[p.index] = p;
            }
            while (true) {
                var keys = Object.keys(currSet);
                var n = keys.length;
                if (n == 0) {
                    break;
                }
                var nextSet = {};
                for (var i = 0 ; i < n ; i++) {
                    var key = keys[i];
                    var p = currSet[key];
                    totalSet[key] = p;
                    for (var j = 0 ; j < p.prev.length ; j++) {
                        var q = p.prev[j];
                        if (q != null) {
                            nextSet[q.index] = q;
                        }
                    }
                }
                currSet = nextSet;
            }

            // collect nodes
            nodes = {};
            for (var x in totalSet) {
                var node = totalSet[x].node;
                if (node != null) {
                    node.collect(nodes, 0); // collect recusively
                }
            }

            var keys = Object.keys(totalSet);
            //console.log(keys.join(', '));

            // Xで分類
            var columns = [];
            for (var i = 0 ; i < keys.length ; i++) {
                var key = keys[i];
                var p = totalSet[key];
                if (columns[p.x] == null) {
                    columns[p.x] = [];
                }
                columns[p.x].push(p);
            }

            // vertex描画
            var gap = 0;
            for (var i = 0 ; i < columns.length ; i++) {
                if (columns[i] == null) { gap++; continue; }
                columns[i].sort(function(a, b) { return a.index - b.index });

                for (var k = 0 ; k < columns[i].length ; k++) {
                    var p = columns[i][k];
                    p.y = k;

                    drawer.drawVertex(p.index, p.entry.index, p.x - gap, p.y);

                    for (var j = 0 ; j < p.prev.length ; j++) {
                        var q = p.prev[j];
                        if (q != null) {
                            drawer.drawVertexEdge(p.index, p.x, p.y,
                                                  q.index, q.x, q.y);
                        }
                    }

                }
            }

            // node描画
            var keys = Object.keys(nodes);
            for (var i = 0 ; i < keys.length ; i++) {
                var p = nodes[keys[i]];
                drawer.drawNode(p.nodeIndex, p.x, p.depth, p.toString());
            }
            for (var i = 0 ; i < keys.length ; i++) {
                var p = nodes[keys[i]];
                if (p.successors != null) {
                    for (var j = 0 ; j < p.successors.length ; j++) {
                        for (var k = 0 ; k < p.successors[j].length ; k++) {
                            var q = p.successors[j][k];
                            drawer.drawNodeEdge(p.nodeIndex, q.nodeIndex);
                        }
                    }
                }
            }

            // vertex->node描画
            for (var i = 0 ; i < columns.length ; i++) {
                if (columns[i] == null) { continue; }

                for (var k = 0 ; k < columns[i].length ; k++) {
                    var p = columns[i][k];
                    if (p.node != null) {
                        drawer.drawVertexToNodeEdge(p.index, p.node.nodeIndex);
                    }
                }
            }

        }
    };

    return exports;
})();

)"
        );
}
