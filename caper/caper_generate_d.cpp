// Copyright (C) 2008 Naoyuki Hirayama.
// All Rights Reserved.

// $Id$

#include "caper_ast.hpp"
#include "caper_generate_cpp.hpp"
#include "caper_format.hpp"
#include "caper_stencil.hpp"
#include "caper_finder.hpp"
#include <algorithm>
#include <boost/tuple/tuple.hpp>
#include <boost/tuple/tuple_comparison.hpp>
#include <boost/filesystem/path.hpp>

namespace {

std::string make_type_name(const Type& x) {
    switch(x.extension) {
        case Extension::None:
            return x.name;
        case Extension::Star:
        case Extension::Plus:
        case Extension::Slash:
            return "Sequence<" + x.name + ">";
        case Extension::Question:
            return "Optional<" + x.name + ">";
        default:
            assert(0);
            return "";
    }
}
        
std::string make_arg_decl(const Type& x, size_t l) {
    std::string sl = std::to_string(l);
    std::string y = make_type_name(x) + " arg" + sl;
    switch (x.extension) {
        case Extension::None:
            return y;
        case Extension::Star:
        case Extension::Plus:
        case Extension::Question:
        case Extension::Slash:
            return
                y + "(sa_, stack_, seq_get_range(base, arg_index" + sl + "))";
        default:
            assert(0);
            return "";
    }
}

void make_signature(
    const std::map<std::string, Type>&      nonterminal_types,
    const tgt::parsing_table::rule_type&    rule,
    const SemanticAction&                   sa,
    std::vector<std::string>&               signature) {
    // function name
    signature.push_back(sa.name);

    // return value
    signature.push_back(
        make_type_name(*finder(nonterminal_types, rule.left().name())));

    // arguments
    for (const auto& arg: sa.args) {
        signature.push_back(make_type_name(arg.type));
    }
}

} // unnamed namespace

void generate_d(
    const std::string&                  src_filename,
    std::ostream&                       os,
    const GenerateOptions&              options,
    const std::map<std::string, Type>&,
    const std::map<std::string, Type>&  nonterminal_types,
    const std::vector<std::string>&     tokens,
    const action_map_type&              actions,
    const tgt::parsing_table&           table) {

    std::string module_name =
        boost::filesystem::path(src_filename).stem().string();

    // notice / URL / module / imports
    stencil(
        os, R"(
// This file was automatically generated by Caper.
// (http://jonigata.github.io/caper/caper.html)

module ${module_name};

import std.array;
import std.stdio;

)",
        {"module_name", module_name}
        );

    if (!options.external_token) {
        // token enumeration
        stencil(
            os, R"(
enum Token {
$${tokens}
}

string token_label(Token t) {
    static string[] labels = [
$${labels}
    ];
    return labels[t];
}

)",
            {"tokens", [&](std::ostream& os){
                    for(const auto& token: tokens) {
                        stencil(
                            os, R"(
    ${prefix}${token},
)",
                            {"prefix", options.token_prefix},
                            {"token", token}
                            );
                    }
                }},
            {"labels", [&](std::ostream& os){
                    for(const auto& token: tokens) {
                        stencil(
                            os, R"(
        "${prefix}${token}",
)",
                            {"prefix", options.token_prefix},
                            {"token", token}
                            );
                    }
                }}
            );

    }

    // stack
    stencil(
        os, R"(
class Stack(T) {
public:
    this() { gap_ = 0; }

    void rollback_tmp() {
        gap_ = stack_.length;
        tmp_.length = 0;
    }

    void commit_tmp() {
        // expect not to throw
        stack_.length = gap_;
        stack_ ~= tmp_;
        tmp_.length = 0;
    }
    bool push(T f) {
        tmp_ ~= f;
        return true;
    }
	   
    void pop(uint n) {
        if (tmp_.length < n) {
            n -= tmp_.length;
            tmp_.length = 0;
            gap_ -= n;
        } else {
            tmp_.length -= n;
        }
    }

    T* top() {
        assert(0 < depth());
        if (0 < tmp_.length) {
            return &tmp_.back;
        } else {
            return &stack_[gap_ - 1];
        }
    }
	   
    T* get_arg(uint base, uint index) {
        uint n = tmp_.length;
        if (base - index <= n) {
            return &tmp_[n - (base - index)];
        } else {
            return &stack_[gap_ - (base - n) + index];
        }
    }
	   
    void clear() {
        stack_.length = 0;
        tmp_.length = 0;
        gap_ = 0; 
    }
	   
    bool empty() {
        if (0 < tmp_.length) {
            return false;
        } else {
            return gap_ == 0;
        }
    }
	   
    uint depth() {
        return gap_ + tmp_.length;
    }
	   
    T* nth(uint index) {
        if (gap_ <= index) {
            return &tmp_[index - gap_];
        } else {
            return &stack_[index];
        }
    }

    void swap_top_and_second() {
        uint d = depth();
        assert(2 <= d);
        T x = *nth(d - 1);
        *nth(d - 1) = *nth(d - 2);
        *nth(d - 2) = x;
    }

private:
    T[] stack_;
    T[] tmp_;
    uint gap_;
	   
};

)");

    // parser class header
    stencil(
        os, R"(
class Parser(Value, SemanticAction) {
    alias Token TokenType;
    alias Value ValueType;

    enum Nonterminal {
)",
        {"token_parameter", options.external_token ? "class Token, " : ""},
        {"default_stack_size", options.dont_use_stl ? "1024" : "0"}
        );

    for (const auto& nonterminal_type: nonterminal_types) {
        stencil(
            os, R"(
        ${nonterminal_name},
)",
            {"nonterminal_name", nonterminal_type.first}
            );
    }
    
    stencil(
        os, R"(
    }

    this(SemanticAction sa){ sa_ = sa; reset(); }

    void reset() {
        error_ = false;
        accepted_ = false;
        stack_ = new typeof(stack_);
        clear_stack();
        rollback_tmp_stack();
        ValueType defaultValue;
        if (push_stack(${first_state}, defaultValue)) {
            commit_tmp_stack();
        } else {
            sa_.stack_overflow();
            error_ = true;
        }
    }

    bool post(TokenType token, ValueType value) {
        rollback_tmp_stack();
        error_ = false;
        while((stack_top().entry.state)(this, token, value)){ }
        if (!error_) {
            commit_tmp_stack();
        } else {
            recover(token, value);
        }
        return accepted_ || error_;
    }

    bool accept(out ValueType v) {
        assert(accepted_);
        if (error_) { return false; }
        v = accepted_value_;
        return true;
    }

    bool error() { return error_; }

)",
        {"first_state", table.first_state()}
        );

    // implementation
    stencil(
        os, R"(
private:
    alias typeof(this) self_type;
    alias bool function(self_type, TokenType, ValueType) state_type;
    alias int function(Nonterminal) gotof_type;

    bool        accepted_;
    bool        error_;
    ValueType   accepted_value_;

    SemanticAction sa_;

    struct table_entry {
        state_type  state;
        gotof_type  gotof;
        bool        handle_error;
    };

    struct stack_frame {
        table_entry*    entry;
        ValueType       value;
        int             sequence_length;
    };

)",
        {"token_paremter", options.external_token ? "Token, " : ""}
        );

    // stack operation
    stencil(
        os, R"(
    Stack!(stack_frame) stack_;

    bool push_stack(int state_index, ValueType v, int sl = 0) {
	bool f = stack_.push(stack_frame(entry(state_index), v, sl));
        assert(!error_);
        if (!f) { 
            error_ = true;
            sa_.stack_overflow();
        }
        return f;
    }

    void pop_stack(uint n) {
$${pop_stack_implementation}
    }

    stack_frame* stack_top() {
        return stack_.top();
    }

    ValueType* get_arg(size_t base, size_t index) {
        return &stack_.get_arg(base, index).value;
    }

    void clear_stack() {
        stack_.clear();
    }

    void rollback_tmp_stack() {
        stack_.rollback_tmp();
    }

    void commit_tmp_stack() {
        stack_.commit_tmp();
    }

)",
        {"pop_stack_implementation", [&](std::ostream& os) {
                if (options.allow_ebnf) {
                    stencil(
                        os, R"(
        int nn = int(n);
        while(nn--) {
            stack_.pop(1 + stack_.top().sequence_length);
        }
)"
                        );
                } else {
                    stencil(
                        os, R"(
        stack_.pop(n);
)"
                        );
                }
            }}
        );

    if (options.recovery) {
        stencil(
            os, R"(
    void recover(TokenType token, ValueType value) {
        rollback_tmp_stack();
        error_ = false;
$${debmes:start}
        while(!stack_top().entry.handle_error) {
            pop_stack(1);
            if (stack_.empty()) {
$${debmes:failed}
                error_ = true;
                return;
            }
        }
$${debmes:done}
        // post error_token;
$${debmes:post_error_start}
        ValueType defaultValue;
        while((stack_top().state)(this, Token.${recover_token}, defaultValue)){}
$${debmes:post_error_done}
        commit_tmp_stack();
        // repost original token
        // if it still causes error, discard it;
$${debmes:repost_start}
        while((stack_top().state)(this, token, value)){ }
$${debmes:repost_done}
        if (!error_) {
            commit_tmp_stack();
        }
        if (token != Token.${token_eof}) {
            error_ = false;
        }
    }

)",
            {"recovery_token", options.token_prefix + options.recovery_token},
            {"token_eof", options.token_prefix + "eof"},
            {"debmes:start", {
                    options.debug_parser ?
                        R"(        stderr.writefln("recover rewinding start: stack depth = %d", stack_.depth());
)" :
                        ""}},
            {"debmes:failed", {
                    options.debug_parser ?
                        R"(        stderr.writeln("recover rewinding failed");
)" :
                        ""}},
            {"debmes:done", {
                    options.debug_parser ?
                        R"(        stderr.writeln("recover rewinding done: stack depth = %d", stack_.depth());
)":
                        ""}},
            {"debmes:post_error_start", {
                    options.debug_parser ?
                        R"(        stderr.writeln("posting error token");
)" :
                        ""}},
            {"debmes:post_error_done", {
                    options.debug_parser ?
                        R"(        stderr.writeln("posting error token done");
)" :
                        ""}},
            {"debmes:repost_start", {
                    options.debug_parser ?
                        R"(        stderr.writeln("reposting original token");
)" :
                        ""}},
            {"debmes:repost_done", {
                    options.debug_parser ? 
                        R"(        stderr.writeln("reposting original token done");
)" :
                        ""}}
            );
    } else {
        stencil(
            os, R"(
    void recover(TokenType, ValueType) {
    }

)"
            );
    }

    if (options.allow_ebnf) {
        stencil(
            os, R"(
    // EBNF support class
    struct Range {
        int beg;
        int end;
        Range() : beg(-1), end(-1) {}
        Range(int b, int e) : beg(b), end(e) {}
    };

    template <class T>
    class Optional {
    public:
        typedef Stack<stack_frame, StackSize> stack_type;

    public:
        Optional(SemanticAction& sa, stack_type& s, const Range& r)
            : sa_(&sa), s_(&s), p_(r.beg == r.end ? -1 : r.beg){}

        operator bool() const {
            return 0 <= p_;
        }
        bool operator!() const {
            return !bool(*this);
        }
        T operator*() const {
            value_type v;
            sa_->downcast(v, s_->nth(p_).value);
            return v;
        }

    private:
        SemanticAction* sa_;
        stack_type*     s_;
        int             p_;

    };

    template <class T>
    class Sequence {
    public:
        typedef Stack<stack_frame, StackSize> stack_type;

        class const_iterator {
        public:
            typedef T value_type;

        public:
            const_iterator(SemanticAction& sa, stack_type& s, int p)
                : sa_(&sa), s_(&s), p_(p){}
            const_iterator(const const_iterator& x) : s_(x.s_), p_(x.p_){}
            const_iterator& operator=(const const_iterator& x) {
                sa_ = x.sa_;
                s_ = x.s_;
                p_ = x.p_;
                return *this;
            }
            value_type operator*() const {
                value_type v;
                sa_->downcast(v, s_->nth(p_).value);
                return v;
            }
            const_iterator& operator++() {
                ++p_;
                return *this;
            }
            bool operator==(const const_iterator& x) const {
                return p_ == x.p_;
            }
            bool operator!=(const const_iterator& x) const {
                return !((*this)==x);
            }
        private:
            SemanticAction* sa_;
            stack_type*     s_;
            int             p_;

        };

    public:
        Sequence(SemanticAction& sa, stack_type& stack, const Range& r)
            : sa_(sa), stack_(stack), range_(r) {
        }

        const_iterator begin() const {
            return const_iterator(sa_, stack_, range_.beg);
        }
        const_iterator end() const {
            return const_iterator(sa_, stack_, range_.end);
        }

    private:
        SemanticAction& sa_;
        stack_type&     stack_;
        Range           range_;

    };

    // EBNF support member functions
    bool seq_head(Nonterminal nonterminal, int base) {
        // case '*': base == 0
        // case '+': base == 1
        int dest = (this->*(stack_nth_top(base)->entry->gotof))(nonterminal);
        return push_stack(dest, value_type(), base);
    }

    bool seq_trail(Nonterminal, int base) {
        // '*', '+' trailer
        assert(base == 2);
        stack_.swap_top_and_second();
        stack_top()->sequence_length++;
        return true;
    }

    bool seq_trail2(Nonterminal, int base) {
        // '/' trailer
        assert(base == 3);
        stack_.swap_top_and_second();
        pop_stack(1); // erase delimiter
        stack_.swap_top_and_second();
        stack_top()->sequence_length++;
        return true;
    }

    bool opt_nothing(Nonterminal nonterminal, int base) {
        // same as head of '*'
        assert(base == 0);
        return seq_head(nonterminal, base);
    }

    bool opt_just(Nonterminal nonterminal, int base) {
        // same as head of '+'
        assert(base == 1);
        return seq_head(nonterminal, base);
    }

    Range seq_get_range(size_t base, size_t index) {
        // returns beg = end if length = 0 (includes scalar value)
        // distinguishing 0-length-vector against scalar value is
        // caller's responsibility
        int n = int(base - index);
        assert(0 < n);
        int prev_actual_index;
        int actual_index  = stack_.depth();
        while(n--) {
            actual_index--;
            prev_actual_index = actual_index;
            actual_index -= stack_.nth(actual_index).sequence_length;
        }
        return Range(actual_index, prev_actual_index);
    }

    const value_type& seq_get_arg(size_t base, size_t index) {
        Range r = seq_get_range(base, index);
        // multiple value appearing here is not supported now
        assert(r.end - r.beg == 0); 
        return stack_.nth(r.beg).value;
    }

    stack_frame* stack_nth_top(int n) {
        Range r = seq_get_range(n + 1, 0);
        // multiple value appearing here is not supported now
        assert(r.end - r.beg == 0);
        return &stack_.nth(r.beg);
    }
)"
            );
    }

    stencil(
        os, R"(
    bool call_nothing(Nonterminal nonterminal, int base) {
        pop_stack(base);
        int dest_index = (stack_top().entry.gotof)(nonterminal);
        ValueType defaultValue;
        return push_stack(dest_index, defaultValue);
    }

)"
        );

    // member function signature -> index
    std::map<std::vector<std::string>, int> stub_indices;
    {
        // member function name -> count
        std::unordered_map<std::string, int> stub_counts; 

        // action handler stub
        for (const auto& pair: actions) {
            const auto& rule = pair.first;
            const auto& sa = pair.second;

            if (sa.special) {
                continue;
            }

            const auto& rule_type =
                *finder(nonterminal_types, rule.left().name());

            // make signature
            std::vector<std::string> signature;
            make_signature(
                nonterminal_types,
                rule,
                sa,
                signature);

            // skip duplicated
            if (0 < stub_indices.count(signature)) {
                continue;
            }

            // make function name
            if (stub_counts.count(sa.name) == 0) {
                stub_counts[sa.name] = 0;
            }
            int stub_index = stub_counts[sa.name];
            stub_indices[signature] = stub_index;
            stub_counts[sa.name] = stub_index+1;

            // header
            stencil(
                os, R"(
    bool call_${stub_index}_${sa_name}(Nonterminal nonterminal, int base${args}) {
)",
                {"stub_index", stub_index},
                {"sa_name", sa.name},
                {"args", [&](std::ostream& os) {
                        for (size_t l = 0 ; l < sa.args.size() ; l++) {
                            os << ", int arg_index" << l;
                        }
                    }}
                );

            // check sequence conciousness
            std::string get_arg = "get_arg";
            for (const auto& arg: sa.args) {
                if (arg.type.extension != Extension::None) {
                    get_arg = "seq_get_arg";
                    break;
                }
            }

            // automatic argument conversion
            for (size_t l = 0 ; l < sa.args.size() ; l++) {
                const auto& arg = sa.args[l];
                if (arg.type.extension == Extension::None) {
                    stencil(
                        os, R"(
        ${arg_type} arg${index}; sa_.downcast(arg${index}, *${get_arg}(base, arg_index${index}));
)",
                        {"arg_type", make_type_name(arg.type)},
                        {"get_arg", get_arg},
                        {"index", l}
                        );
                } else {
                    stencil(
                        os, R"(
        ${arg_decl}; 
)",
                        {"arg_decl", make_arg_decl(arg.type, l)}
                        );
                }
            }

            // semantic action / automatic value conversion
            stencil(
                os, R"(
        ${nonterminal_type} r = sa_.${semantic_action_name}(${args});
        ValueType v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (stack_top().entry.gotof)(nonterminal);
        return push_stack(dest_index, v);
    }

)",
                {"nonterminal_type", make_type_name(rule_type)},
                {"semantic_action_name", sa.name},
                {"args", [&](std::ostream& os) {
                        bool first = true;
                        for (size_t l = 0 ; l < sa.args.size() ; l++) {
                            if (first) { first = false; }
                            else { os << ", "; }
                            os << "arg" << l;
                        }
                    }}
                );
        }
    }

    // states handler
    for (const auto& state: table.states()) {
        // state header
        stencil(
            os, R"(
    static bool state_${state_no}(self_type self, TokenType token, ValueType value) {
$${debmes:state}
        switch(token) {
)",
            {"state_no", state.no},
            {"debmes:state", [&](std::ostream& os){
                    if (options.debug_parser) {
                        stencil(
                            os, R"(
        stderr.writefln("state_${state_no} << %s", token_label(token));
)",
                            {"state_no", state.no}
                            );
                    }}}
            );

        // reduce action cache
        typedef boost::tuple<
            std::vector<std::string>,
            std::string,
            size_t,
            std::vector<int>>
            reduce_action_cache_key_type;
        typedef 
            std::map<reduce_action_cache_key_type,
                     std::vector<std::string>>
            reduce_action_cache_type;
        reduce_action_cache_type reduce_action_cache;

        // action table
        for (const auto& pair: state.action_table) {
            const auto& token = pair.first;
            const auto& action = pair.second;

            const auto& rule = action.rule;

            // action header 
            std::string case_tag =
                "Token." + options.token_prefix + tokens[token];

            // action
            switch (action.type) {
                case zw::gr::action_shift:
                    stencil(
                        os, R"(
        case ${case_tag}:
            // shift
            self.push_stack(/*state*/ ${dest_index}, value);
            return false;
)",
                        {"case_tag", case_tag},
                        {"dest_index", action.dest_index}
                        );
                    break;
                case zw::gr::action_reduce: {
                    size_t base = rule.right().size();
                    const std::string& rule_name = rule.left().name();

                    auto k = finder(actions, rule);
                    if (k && !(*k).special) {
                        const auto& sa = *k;

                        std::vector<std::string> signature;
                        make_signature(
                            nonterminal_types,
                            rule,
                            sa,
                            signature);

                        reduce_action_cache_key_type key =
                            boost::make_tuple(
                                signature,
                                rule_name,
                                base,
                                sa.source_indices);

                        reduce_action_cache[key].push_back(case_tag);
                    } else {
                        stencil(
                            os, R"(
        case ${case_tag}:
)",
                            {"case_tag", case_tag}
                            );
                        std::string funcname = "call_nothing";
                        if (k) {
                            const auto& sa = *k;
                            assert(sa.special);
                            funcname = sa.name;
                        }
                        stencil(
                            os, R"(
            // reduce
            return self.${funcname}(Nonterminal.${nonterminal}, /*pop*/ ${base});
)",
                            {"funcname", funcname},
                            {"nonterminal", rule.left().name()},
                            {"base", base}
                            );
                    }
                }
                    break;
                case zw::gr::action_accept:
                    stencil(
                        os, R"(
        case ${case_tag}:
            // accept
            self.accepted_ = true;
            self.accepted_value_ = *self.get_arg(1, 0);
            return false;
)",
                        {"case_tag", case_tag}
                        );
                    break;
                case zw::gr::action_error:
                    stencil(
                        os, R"(
        case ${case_tag}:
            self.sa_.syntax_error();
            self.error_ = true;
            return false;
)",
                        {"case_tag", case_tag}
                        );
                    break;
            }

            // action footer
        }

        // flush reduce action cache
        for(const auto& pair: reduce_action_cache) {
            const reduce_action_cache_key_type& key = pair.first;
            const std::vector<std::string>& cases = pair.second;

            const std::vector<std::string>& signature = key.get<0>();
            const std::string& nonterminal_name = key.get<1>();
            size_t base = key.get<2>();
            const std::vector<int>& arg_indices = key.get<3>();

            for (size_t j = 0 ; j < cases.size() ; j++){
                // fall through, be aware when port to other language
                stencil(
                    os, R"(
        case ${case}:
)",
                    {"case", cases[j]}
                    );
            }

            int index = stub_indices[signature];

            stencil(
                os, R"(
            // reduce
            return self.call_${index}_${sa_name}(Nonterminal.${nonterminal}, /*pop*/ ${base}${args});
)",
                {"index", index},
                {"sa_name", signature[0]},
                {"nonterminal", nonterminal_name},
                {"base", base},
                {"args", [&](std::ostream& os) {
                        for(const auto& x: arg_indices) {
                            os  << ", " << x;
                        }
                    }}
                );
        }

        // dispatcher footer / state footer
        stencil(
            os, R"(
        default:
            self.sa_.syntax_error();
            self.error_ = true;
            return false;
        }
    }

)"
            );

        // gotof header
        stencil(
            os, R"(
    static int gotof_${state_no}(Nonterminal nonterminal) {
)",
            {"state_no", state.no}
            );
            
        // gotof dispatcher
        std::stringstream ss;
        stencil(
            ss, R"(
        switch(nonterminal) {
)"
            );
        bool output_switch = false;
        for (const auto& pair: state.goto_table) {
            stencil(
                ss, R"(
        case Nonterminal.${nonterminal}: return ${state_index};
)",
                {"nonterminal", pair.first.name()},
                {"state_index", pair.second}
                );
            output_switch = true;
        }

        // gotof footer
        stencil(
            ss, R"(
        default: assert(0); return false;
        }
)"
            );
        if (output_switch) {
            os << ss.str();
        } else {
            stencil(
                os, R"(
        assert(0);
        return true;
)"
                );
        }
        stencil(os, R"(
    }

)"
                );


    }

    // table
    stencil(
        os, R"(
    table_entry* entry(int n) {
        static table_entry entries[] = [
$${entries}
        ];
        return &entries[n];
    }

)",
        {"entries", [&](std::ostream& os) {
                int i = 0;
                for (const auto& state: table.states()) {
                    stencil(
                        os, R"(
            { &state_${i}, &gotof_${i}, ${handle_error} },
)",
                            
                        {"i", i},
                        {"handle_error", state.handle_error}
                        );
                    ++i;
                }                    
            }}
        );

    // parser class footer
    // namespace footer
    // once footer
    stencil(
        os,
        R"(
};

)"
        );
}
